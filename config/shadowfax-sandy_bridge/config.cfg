[MAIN]
# Enable debug log mode (def False)
#debug=
# Enable info log mode (def False)
#info=
# Enable quiet/warning log mode (def False)
#quiet=

[basic]
# Print build overview incl. dependencies (full paths) (def False)
#dry-run=
# Print build overview incl. dependencies (short paths) (def False)
#dry-run-short=
# Force to rebuild software even if it's already installed (i.e. if it can be found as module) (def False)
#force=
# Submit the build as a job (def False)
#job=
# Redirect main log to stdout (def False)
#logtostdout=
# Only build listed blocks
#only-blocks=
# Enable dependency resolution, using easyconfigs in specified paths (type pathsep-separated list; def )
#robot=

# Additional paths to consider by robot for easyconfigs (--robot paths get priority) (type pathsep-separated list; def /apps/easybuild/software/shadowfax-sandy_bridge/Core/EasyBuild/2.0.0/lib64/python2.6/site-packages/easybuild_easyconfigs-2.0.0-py2.6.egg/easybuild/easyconfigs)
#robot-paths=
# here we define the default search path, and order, of our easyconfigs:
# 1) VBI custom repo/cluster specific
# 2) VBI custom repo/generic
# 3) VBI easybuild results/cluster specific
# 4) default easybuild
robot-paths=/apps/easybuild/ebfiles_repo-vbi/shadowfax-sandy_bridge:/apps/easybuild/ebfiles_repo-vbi/generic:/apps/easybuild/ebfiles_repo/shadowfax-sandy_bridge:%(DEFAULT_ROBOT_PATHS)s


# Skip existing software (useful for installing additional packages) (def False)
#skip=
# Stop the installation after certain step (type choice; def source) (choices: fetch, ready, source, patch, prepare, configure, build, test, install, extensions, package, postproc, sanitycheck, cleanup, module, testcases)
#stop=
# Set strictness level (type choice; def warn) (choices: ignore, warn, error)
#strict=

[config]
# Show all supported module naming schemes (def False)
#avail-module-naming-schemes=
# Show all supported module tools (def False)
#avail-modules-tools=
# Show all repository types (incl. non-usable) (def False)
#avail-repositories=
# Temporary build path (def /home/dom/.local/easybuild/build)
buildpath=/dev/shm/$USER/build
# Directory names to ignore when searching for files/dirs (type comma-separated list; def .git,.svn)
#ignore-dirs=
# Install path for software and modules (def /home/dom/.local/easybuild)
#installpath=
# Directory name and format of the log file (type comma-separated tuple; def easybuild,easybuild-%(name)s-%(version)s-%(date)s.%(time)s.log)
#logfile-format=
# Module naming scheme (type choice; def EasyBuildMNS) (choices: CategorizedHMNS, EasyBuildMNS, HierarchicalMNS)
module-naming-scheme=EasyBuildMNS
# Extend supported module classes (For more info on the default classes, use --show-default-moduleclasses) (def ['base', 'bio', 'cae', 'chem', 'compiler', 'data', 'debugger', 'devel', 'geo', 'ide', 'lang', 'lib', 'math', 'mpi', 'numlib', 'perf', 'phys', 'system', 'toolchain', 'tools', 'vis'])
#moduleclasses=
# Path to file containing footer to be added to all generated module files
#modules-footer=
# Modules tool to use (type choice; def EnvironmentModulesC) (choices: EnvironmentModulesC, EnvironmentModulesTcl, Lmod)
modules-tool=EnvironmentModulesC
# Change prefix for buildpath, installpath, sourcepath and repositorypath (used prefix for defaults /home/dom/.local/easybuild)
#prefix=
# Enable generating of modules that unload recursively. (def False)
#recursive-module-unload=
# Repository type, using repositorypath (type choice; def FileRepository) (choices: FileRepository)
repository=FileRepository
# Repository path, used by repository (is passed as list of arguments to create the repository instance). For more info, use --avail-repositories. (type comma-separated list; def /home/dom/.local/easybuild/ebfiles_repo)
repositorypath=/apps/easybuild/ebfiles_repo/shadowfax-sandy_bridge
# Show default module classes with description (def False)
#show-default-moduleclasses=
# Path(s) to where sources should be downloaded (string, colon-separated) (def /home/dom/.local/easybuild/sources)
sourcepath=/apps/easybuild/sources
# Installpath subdir for modules (def modules)
#subdir-modules=/apps/easybuild/modules/shadowfax-sandy_bridge
installpath-modules=/apps/easybuild/modules/shadowfax-sandy_bridge
# Installpath subdir for software (def software)
#subdir-software=/apps/easybuild/software/shadowfax-sandy_bridge
installpath-software=/apps/easybuild/software/shadowfax-sandy_bridge

# Suffix for module files install path (def all)
#suffix-modules-path=
# Path to where a job should place the output (to be set within jobscript)
#testoutput=
# Log directory where temporary log files are stored
#tmp-logdir=
# Directory to use for temporary storage
#tmpdir=

[informative]
# Show all constants that can be used in configuration files (def False)
#avail-cfgfile-constants=
# Show all constants that can be used in easyconfigs (def False)
#avail-easyconfig-constants=
# Show all license constants that can be used in easyconfigs (def False)
#avail-easyconfig-licenses=
# Show all easyconfig parameters (include easyblock-specific ones by using -e) (type choice; def txt) (choices: rst, txt)
#avail-easyconfig-params=
# Show all template names and template constants that can be used in easyconfigs (def False)
#avail-easyconfig-templates=
# Create dependency graph
#dep-graph=
# Show list of available easyblocks (type choice; def simple) (choices: simple, detailed)
#list-easyblocks=
# Show list of known toolchains (def False)
#list-toolchains=
# Search for easyconfig files in the robot directory, print full paths
#search=
# Search for easyconfig files in the robot directory, print short paths
#search-short=

[override]
# Allow mismatch of modules tool and definition of 'module' function (def False)
#allow-modules-tool-mismatch=
# Cleanup build dir after successful installation. (def True)
#cleanup-builddir=
# Run pretending to be (future) version, to test removal of deprecated code.
#deprecated=
# Timeout for initiating downloads (in seconds)
#download-timeout=
# easyblock to use for processing the spec file or dumping the options
#easyblock=
# Allow experimental code (with behaviour that can be changed/removed at any given time). (def False)
#experimental=
# Comma separated list of dependencies that you DON'T want to install with EasyBuild, because equivalent OS packages are installed. (e.g. --filter-deps=zlib,ncurses) (type <type 'str'>)
#filter-deps=
# Group to be used for software installations (only verified, not set)
group=hpcadmin
# Install 'hidden' module file(s) by prefixing their name with '.' (def False)
#hidden=
# Ignore any listed OS dependencies (def False)
#ignore-osdeps=
# Look for and use the oldstyle configuration file. (def True)
#oldstyleconfig=
# Set architecture optimization, overriding native architecture optimizations
#optarch=
# Does the build/installation in a test directory located in $HOME/easybuildinstall (def False)
#pretend=
# Set group ID bit on newly created directories (def False)
set-gid-bit=True
# Skip running test cases (def False)
#skip-test-cases=
# Set sticky bit on newly created directories (def False)
sticky-bit=True
# umask to use (e.g. '022'); non-user write permissions on install directories are removed
umask=002
# Update modules tool cache file(s) after generating module file (def False)
#update-modules-tool-cache=

[regtest]
# Collect all the xmls inside the given directory and generate a single file
#aggregate-regtest=
# Dump test report to specified path (def test_report.md)
#dump-test-report=
# GitHub username
#github-user=
# Enable regression test mode (def False)
#regtest=
# Set output directory for test-run
#regtest-output-dir=
# Specify this option if you want to prevent parallel build (def False)
#sequential=
# Regex used to filter out variables in environment dump of test report
#test-report-env-filter=
# Upload full test report as a gist on GitHub (def False)
#upload-test-report=

[software]
# Specify additional search and build parameters (can be used multiple times); for example: versionprefix=foo or patches=one.patch,two.patch)
#amend=
# Obtain easyconfigs from specified PR (type <type 'int'>)
#from-pr=
# Search and build software with given name and version
#software=
# Search and build software with given name
#software-name=
# Search and build software with given version
#software-version=
# Search and build with given toolchain (name and version)
#toolchain=
# Search and build with given toolchain name
#toolchain-name=
# Search and build with given toolchain version
#toolchain-version=
# Try to specify additional search and build parameters (can be used multiple times); for example: versionprefix=foo or patches=one.patch,two.patch) (USE WITH CARE!)
#try-amend=
# Try to search and build software with given name and version (USE WITH CARE!)
#try-software=
# Try to search and build software with given name (USE WITH CARE!)
#try-software-name=
# Try to search and build software with given version (USE WITH CARE!)
#try-software-version=
# Try to search and build with given toolchain (name and version) (USE WITH CARE!)
#try-toolchain=
# Try to search and build with given toolchain name (USE WITH CARE!)
#try-toolchain-name=
# Try to search and build with given toolchain version (USE WITH CARE!)
#try-toolchain-version=

[unittest]
# Log to this file in unittest mode
#unittest-file=
